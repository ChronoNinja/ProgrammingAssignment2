hist(x)
}
if (x > 3) {
print("hello")
}
x <- rnorm(100)
d <- list(1,2,3)
hist(x)
x <- 5
x
print(x)
x <- 1:20
x
x <- c(0.5,0.6)
x
x <- c(TRUE,FALSE)
x
x <- vector("numeric", length = 10)
x
y <- c(1.7,"a")
y
y <- c(TRUE,2)
y
y <- c("a",TRUE)
y
x <- 0:6
x
class(x)
as.numeric(x)
as.logical(x)
m <- matrix(nrow = 2, ncol = 3)
m
dim(m)
attributes(m)
m <-matrix(1:6,nrow=2,ncol=3)
m
m <- 1:6
m
dim(m) <- c(2,3)
m
x <- c(0.517,0.521,0.523,0.531,0.532,0.532,0.531,0.532)
plot(x)
Scan008 <- c(2.029,2.040,2.042,2.038,2.040,2.038,2.028,2.025,2.024,2.028)
sdec(Scan008)
Scan008 <- c(2.029,2.040,2.042,2.038,2.040,2.038,2.028,2.025,2.024,2.028)
sdev(Scan008)
Scan008 <- c(2.029,2.040,2.042,2.038,2.040,2.038,2.028,2.025,2.024,2.028)
sd(Scan008)
Scan008 <- c(2.029,2.040,2.042,2.038,2.040,2.038,2.028,2.025,2.024,2.028,2.029,2.029)
sd(Scan008)
Scan008 <- c(2.029,2.040,2.042,2.038,2.040,2.038,2.028,2.025,2.024,2.028,2.029,2.029)
mean(Scan008)
sd(Scan008)
x <- c("a","b","c","c","d","a")
x[1]
x <- c("a","b","c","c","d","a")
x[1]
x[2]
x[1:4]
x[ x > "a"]
u <- x > "a"
u
x[u]
x <- matrix(1:6,2,3)
x[1,2]
x[2,1]
x[1, ,drop = FALSE]
x[2, ,drop = FALSE]
x <- list(foo = 1:4, bar=0.6)
x[1]
x[2]
attributes(x)
x[foo]
x["foo"]
x[[1]]
x[[2]]
x$bar
x$foo
x <- list(foo = 1:4, bar = 0.6, baz = "hello")
x[c(1,3)]
name <- "foo"
x[[name]]
x$name
x$foo
x <- list(a = list(10,12,14), b=c(3.14,2.81))
x[[c(1,3)]]
x[[c(2,2)]]
x[[c(2,1)]]
x[[c(2,3)]]
x <-list(aardvark = 1:5)
x$a
x$aa
x$v
x <- c(1,2,NA,4,NA,5)
bad <- is.na(x)
bad
x[!bad]
XPS_Th002_Angular_00_degrees_Os1 <- read.delim("~/Documents/Code/ROOT/General_Scripts/Stats/Data/XPS_Th002_Angular_00_degrees_Os1.txt", header=F)
View(XPS_Th002_Angular_00_degrees_Os1)
dim(XPS_Th002_Angular_00_degrees_Os1)
names(XPS_Th002_Angular_00_degrees_Os1)
pc = princomp(~V1+V2,XPS_Th002_Angular_00_degrees_Os1)
pc$loading
pc
names(pc)
pc$scores
screenplot(pc)
plot(pc)
screeplot(pc)
screeplot(pc,type="lines")
pc$loading[,1:2]
M = pc$loading[,1:2]
t(M)
Enot
> sum(Enot)
sum(Enot)
Enot <- (2.95,3.69,3.93,3.73)
Enot <- (2.95, 3.69, 3.93, 3.73)
q()
Enot <- (2.95, 3.69, 3.93, 3.73)
Enot <- (2.95, 3.69, 3.93, 3.73)
x <- (2.95, 3.69, 3.93, 3.73)
x<-(2.95, 3.69, 3.93, 3.73)
Enot<-c(2.95, 3.69, 3.93, 3.73)
Enot
Enot<-c(2.95, 3.69, 3.93, 3.73, 3.71, 3.73)
sum(Enot)
hist(Enot)
boxplot(Enot)
Enot<-c(2.95, 3.69, 3.93, 3.73)
Enot<-c(2.95, 3.69, 3.93, 3.73, 3.71, 3.73)
boxplot(Enot,range=0)
boxplot(delRO,range=0)
boxplot(delRO,range=0)
delRO<-c(2.38,2.37,2.37,2.38,2.38,2.37)
boxplot(delRO,range=0)
ssO<-(0.0009,0.003,0.001,0.001,0.002,0.001)
boxplot(ssO,range=0)
boxplot(ssO,range=0)
boxplot(ssO,range=0)
ssO<-c(0.0009,0.003,0.001,0.001,0.002,0.001)
boxplot(ssO,range=0)
delRTh<-c(3.94,3.94,3.94,3.94,3.94,3.94)
boxplot(delRTh,range=0)
boxplot(ssTh,range=0)
ssTh<-c(0.002,0.002,0.002,0.002,0.002)
boxplot(ssTh,range=0)
boxplot(ssTh,range=0)
ssTh<-c(0.002,0.002,0.002,0.002,0.002)
boxplot(ssTh,range=0)
boxplot(ssO,range=0)
install.packages(swirl)
install.packages("swirl")
formals(mean())
mydata <- rnorm(100)
formals(sd)
sd(x = mydata)
args(sd)
setwd("~/Documents/Coursera/RPROG010/ProgrammingAssignment2")
source(makeVector.R)
source("makeVector.R")
x <- c(1,2,3,4,5,6)
makeVector(x)
source("makeVector.R")
source("cacheMean.R")
x <- c(1,2,3,4,5,6)
makeVector(x)
cacheMean(x)
cacheMean(x)
source("makeVector.R")
source("cacheMean.R")
x <- c(1,2,3,4,5,6)
y <- makeVector(x)
cacheMean(y)
cacheMean(y)
?get
?set
??<<-
?"<<-"
install.packages(knitr)
install(knitr)
?install
??install
install.packages("knitr")
get <- function() x
get
source("makeVector.R")
source("cacheMean.R")
x <- c(1,2,3,4,5,6)
y <- makeVector(x)
cacheMean(y)
cacheMean(y)
source("makeVector.R")
source("cacheMean.R")
x <- c(1,2,3,4,5,6)
y <- makeVector(x)
cacheMean(y)
cacheMean(y)
x <- 1:10
y <- makeVector(x)
cacheMean(y)
cacheMean(y)
source("makeVector.R")
source("cacheMean.R")
x <- c(1,2,3,4,5,6)
y <- makeVector(x)
cacheMean(y)
cacheMean(y)
x <- 1:10
y <- makeVector(x)
cacheMean(y)
x <- 1:20
cacheMean(y)
y <- makeVector(x)
cacheMean(y)
print("Running makeVector and cacheMean")
source("makeVector.R")
source("cacheMean.R")
print("Fill vector x with 2, 4, and 6")
x <- c(2,4,6)
print("Create special vector y")
y <- makeVector(x)
print("Calculate the mean of y")
cacheMean(y)
print("Calculate the mean of y again, but it is cached.")
cacheMean(y)
x <- 1:10
y <- makeVector(x)
cacheMean(y)
x <- 1:20
cacheMean(y)
y <- makeVector(x)
cacheMean(y)
print("Running makeVector and cacheMean")
source("makeVector.R")
source("cacheMean.R")
print("Fill vector x with 2, 4, and 6")
x <- c(2,4,6)
print("Create special vector y")
y <- makeVector(x)
print("Calculate the mean of y")
cacheMean(y)
print("Calculate the mean of y again, but it is cached.")
cacheMean(y)
x <- 1:10
y <- makeVector(x)
cacheMean(y)
x <- 1:20
cacheMean(y)
y <- makeVector(x)
cacheMean(y)
?print
print("Running makeVector and cacheMean");
source("makeVector.R")
source("cacheMean.R")
print("Fill vector x with 2, 4, and 6");
x <- c(2,4,6)
print("Create special vector y");
y <- makeVector(x)
print("Calculate the mean of y");
cacheMean(y)
print("Calculate the mean of y again, but it is cached.");
cacheMean(y)
x <- 1:10
y <- makeVector(x)
cacheMean(y)
x <- 1:20
cacheMean(y)
y <- makeVector(x)
cacheMean(y)
?clear
??clear
message("If working in RStudio, Ctrl+L will clear the console.")
message("Running makeVector and cacheMean");
source("makeVector.R")
source("cacheMean.R")
message("Fill vector x with 2, 4, and 6");
x <- c(2,4,6)
message("Create special vector y");
y <- makeVector(x)
message("Calculate the mean of y");
cacheMean(y)
message("Calculate the mean of y again, but it is cached.");
cacheMean(y)
x <- 1:10
y <- makeVector(x)
cacheMean(y)
x <- 1:20
cacheMean(y)
y <- makeVector(x)
cacheMean(y)
# If working in RStudio, Ctrl+L will clear the console.
# Sourcing makeVector and cacheMean
source("makeVector.R")
source("cacheMean.R")
# Create numeric vector x with 2, 4, and 6
x <- c(2,4,6)
# Create special vector y
y <- makeVector(x)
# Calculate the mean of y
cacheMean(y)
# Calculate the mean of y again, but it is cached
cacheMean(y)
# Now reset x to be 1 through 10
x <- 1:10
# Remake vector y
y <- makeVector(x)
# Caclulate the mean of y, which is now not cached so recalculated
cacheMean(y)
# Demonstrate that it is cached again
cacheMean(y)
# Make x 1 through 20
x <- 1:20
# Notice that this next cacheMean is still the old mean, didn't remake y
cacheMean(y)
# Remake y
y <- makeVector(x)
# Now the cached Mean is correct
cacheMean(y)
# Check to see if indeed cached, good
cacheMean(y)
# If working in RStudio, Ctrl+L will clear the console.
# Sourcing makeVector and cacheMean
source("makeVector.R")
source("cacheMean.R")
# Create numeric vector x with 2, 4, and 6
x <- c(2,4,6)
# Create special vector y
y <- makeVector(x)
# Calculate the mean of y
cacheMean(y)
# Calculate the mean of y again, but it is cached
cacheMean(y)
# Now reset x to be 1 through 10
x <- 1:10
# Remake vector y
y <- makeVector(x)
# Caclulate the mean of y, which is now not cached so recalculated
cacheMean(y)
# Demonstrate that it is cached again
cacheMean(y)
# Make x 1 through 20
x <- 1:20
# Notice that this next cacheMean is still the old mean, didn't remake y
cacheMean(y)
# Remake y
y <- makeVector(x)
# Now the cached Mean is correct
cacheMean(y)
# Check to see if indeed cached, good
cacheMean(y)
source("cachematrix.R")
source("cachematrix.R")
source("cachematrix.R")
source("cachematrix.R")
source("cachematrix.R")
source("cachematrix.R")
source("cachematrix.R")
source("cachematrix.R")
source("cachematrix.R")
source("cachematrix.R")
source("cachematrix.R")
source("cachematrix.R")
source("cachematrix.R")
summary(y)
y$get_matrix
y$get_matrix()
ls()
y
y$retrieveMatrix
y$retrieveMatrix()
source("cachematrix.R")
source("cachematrix.R")
source("cachematrix.R")
##
## Purpose of Code
##
## Original Author (forked from): Roger D. Peng
## Editting Author: Tony Kelly
##
## This R script defines 2 functions.  One function to make and cache a special matrix, and then
## another function to calculate the inverse of the matrix.  This code is essentially built off
## of the template provided by makeVector.R and cacheMean.R , both which contain functions
## makeVector and cacheMean.  Further details of the actual functions are commented in their
## respective sections.
##
## makeVector and cacheMean were actually terribly written in terms of the data dictionary names.
## More effort was made in my code to make the variable names much more descriptive
##
## At the end of this script, there is a testing script that can be uncommented to run the code,
## althrough the instructions tell the User not to execute the R code.
##
## NOTICE: If you are experienced at all with object-oriented programming, then you will notice
##  that this is pretty close to achieving the same effect in R.  It is close enough, that I
##  refer to various sections as Members and Methods.  Also, even though I could have written
##  the embedded function environments as one liners, I prefer to have the same structure to
##  my functions throughout, hence the use of curly braces at the end of each function.  This
##  is a personal coding preference.
##
## makeCacheMatrix takes as its input a numeric matrix
##   The output/return of the makeCacheMatrix is a LIST with the properties
##    set using the functions/methods as described within the body below
makeCacheMatrix <- function(hold_matrix = matrix()) { # pass initial matrix
## Members
## hold_matrix : this is the matrix passed to makeCacheMatrix
## hold_inverse : this is the variable to hold the matrix inverse
hold_inverse <- NULL
## Methods (functions within makeCaheMatrix environment)
## set_matrices : clears the cached values and resets hold_matrix and hold_inverse
## set_inverse  : provides a means of directly setting the hold_inverse to a value
## get_matrix   : returns the value contained in hold_matrix
## get_inverse  : returns the value contained in hold_inverse
set_matrices <- function(new_matrix) {
hold_matrix  <<- new_matrix
hold_inverse <<- NULL
}
set_inverse <- function(new_inverse) {
hold_inverse <<- new_inverse
}
get_matrix <- function() {
## returns hold_matrix
hold_matrix
}
get_inverse <- function() {
## returns hold_inverse
hold_inverse
}
## makeCacheMatrix returns a list with the functions
list(cacheMatrix     = set_matrices,
cacheInverse    = set_inverse,
retrieveMatrix  = get_matrix,
retrieveInverse = get_inverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
}
## The script below was used to debug and test the above code.
## The submission instructions do not ask the User to run the code
## however if the User were to run the code below, it would execute
## an example and implement the above functions.
##
## The 2x2 matrix 4 7 2 6 should have an inverse of 0.6 -0.7 -0.2 0.4
print(environment())
x <- matrix(c(4,7,2,6),c(2,2))
print(x)
y <- makeCacheMatrix(x)
## Check to see if y actually holds the values of the 2x2 matrix
y
## The script below was used to debug and test the above code.
## The submission instructions do not ask the User to run the code
## however if the User were to run the code below, it would execute
## an example and implement the above functions.
##
## The 2x2 matrix 4 7 2 6 should have an inverse of 0.6 -0.7 -0.2 0.4
## Copy this section of code and then hit RUN if using RStudio
print(environment())
x <- matrix(c(4,7,2,6),c(2,2))
print(x)
y <- makeCacheMatrix(x)
## Check to see if y actually holds the values of the 2x2 matrix
y$retrieveMatrix()
## The script below was used to debug and test the above code.
## The submission instructions do not ask the User to run the code
## however if the User were to run the code below, it would execute
## an example and implement the above functions.
##
## The 2x2 matrix 4 7 2 6 should have an inverse of 0.6 -0.7 -0.2 0.4
## Copy this section of code and then hit RUN if using RStudio
print(environment())
x <- matrix(c(4,7,2,6),c(2,2))
print(x)
y <- makeCacheMatrix(x)
## Check to see if y actually holds the values of the 2x2 matrix
y$retrieveMatrix()
## The script below was used to debug and test the above code.
## The submission instructions do not ask the User to run the code
## however if the User were to run the code below, it would execute
## an example and implement the above functions.
##
## The 2x2 matrix 4 7 2 6 should have an inverse of 0.6 -0.7 -0.2 0.4
## Copy this section of code and then hit RUN if using RStudio
## print(environment())
source("cachematrix.R")
x <- matrix(c(4,7,2,6),c(2,2))
print(x)
y <- makeCacheMatrix(x)
## Check to see if y actually holds the values of the 2x2 matrix
y$retrieveMatrix()
## The script below was used to debug and test the above code.
## The submission instructions do not ask the User to run the code
## however if the User were to run the code below, it would execute
## an example and implement the above functions.
##
## The 2x2 matrix 4 7 2 6 should have an inverse of 0.6 -0.7 -0.2 0.4
## Copy this section of code and then hit RUN if using RStudio
## print(environment())
source("cachematrix.R")
x <- matrix(c(4,7,2,6),c(2,2))
print(x)
y <- makeCacheMatrix(x)
## Check to see if y actually holds the values of the 2x2 matrix
y$getMatrix()
y$getInverse()
y$setMatrix(matrix(c(1,2,3,4),c(2,2)))
y$getMatrix()
y$getInverse()
y$setInverse(matrix(c(1,0,0,1),c(2,2)))
y$getMatrix()
y$getInverse()
y <- makeCacheMatrix(x)
y$getMatrix()
y$getInverse()
